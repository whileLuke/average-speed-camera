<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>HUD Speed Tracker — Improved</title>
<style>
  :root{--bg:#000;--muted:#7f8ea3;--panel:#0b1220;--accent:#10b981;}
  html,body{margin:0;padding:0;height:100%;background:var(--bg);color:#fff;font-family:Inter,system-ui; -webkit-font-smoothing:antialiased;overflow:auto;}
  .controls{position:relative;z-index:9999;padding:12px;display:flex;gap:8px;flex-wrap:wrap;align-items:center;background:transparent;}
  .hud{position:fixed;top:56px;left:0;right:0;bottom:0;display:flex;flex-direction:column;justify-content:flex-start;align-items:center;text-align:center;pointer-events:none;padding-top:12px;}
  .gauge{width:120px;height:120px;margin:12px;}
  .group{display:flex;flex-direction:column;align-items:center;margin:18px 8px;pointer-events:none;}
  .value{font-size:24px;font-weight:800;margin-top:-48px;}
  .label{font-size:14px;color:var(--muted);}
  input, button, select{z-index:9999;pointer-events:auto;font-size:14px;padding:8px;border-radius:6px;border:1px solid rgba(255,255,255,0.08);background:var(--panel);color:#fff;}
  .running-indicator{width:14px;height:14px;border-radius:50%;margin-top:8px;background:red;animation:pulse 1s infinite;display:none;}
  @keyframes pulse {0%{opacity:0.3;}50%{opacity:1;}100%{opacity:0.3;}}
  .small{font-size:12px;padding:6px;}
  .row{display:flex;gap:8px;align-items:center;}
  .status{font-size:12px;color:var(--muted);margin-left:6px;}
  .footer{position:fixed;bottom:6px;left:6px;color:var(--muted);font-size:12px;pointer-events:none;}
  .inputs{display:flex;gap:8px;align-items:center;flex-wrap:wrap;}
  .coord{width:120px;}
  .controls .spacer{width:12px;}
  .muted{color:var(--muted);font-size:12px;}
</style>
</head>
<body>

<div class="controls">
  <div class="inputs">
    <input id="latA" class="coord" type="number" placeholder="Start Lat" step="any" />
    <input id="lonA" class="coord" type="number" placeholder="Start Lon" step="any" />
    <button id="setStartManual" class="small">Set Start (manual)</button>

    <div style="width:6px"></div>

    <input id="latB" class="coord" type="number" placeholder="Dest Lat" step="any" />
    <input id="lonB" class="coord" type="number" placeholder="Dest Lon" step="any" />
    <button id="setEndManual" class="small">Set End (manual)</button>

    <div class="spacer"></div>

    <input id="limit" type="number" placeholder="Speed Limit km/h" style="width:120px;" />
    <button id="markStart" class="small">Mark Start (GPS)</button>
    <button id="markEnd" class="small">Mark End (GPS)</button>
    <button id="startBtn" class="small">Start Trip</button>
    <button id="stopBtn" class="small">Stop</button>
    <button id="exportBtn" class="small">Export CSV</button>
  </div>

  <label style="display:flex;align-items:center;gap:6px;margin-left:6px;">
    <input id="autoToggle" type="checkbox" /> Auto start/end
  </label>

  <label style="display:flex;align-items:center;gap:6px;margin-left:6px;">
    <input id="useCoordsSpeed" type="checkbox" checked /> Use GPS speed
  </label>

</div>

<div class="hud">
  <div style="display:flex;gap:24px;flex-wrap:wrap;justify-content:center;width:100%;">
    <div class="group">
      <svg id="curGauge" class="gauge"></svg>
      <div class="value" id="cur">0</div>
      <div class="label">Current Speed</div>
    </div>

    <div class="group">
      <svg id="avgGauge" class="gauge"></svg>
      <div class="value" id="avg">0</div>
      <div class="label">Average So Far</div>
    </div>

    <div class="group">
      <svg id="reqGauge" class="gauge"></svg>
      <div class="value" id="req">—</div>
      <div class="label">Required Average</div>
    </div>

    <div class="group">
      <div class="value" id="distB">—</div>
      <div class="label">Distance to Destination (km)</div>
    </div>
  </div>

  <div class="running-indicator" id="indicator"></div>
  <div class="status" id="statusText" style="margin-top:12px;pointer-events:none;"></div>
</div>

<div class="footer">Improved: route-distance + smoothing + GPS filtering</div>

<script>
/* ---------- Utilities ---------- */
function toRad(d){return d*Math.PI/180;}
function validLat(lat){return typeof lat === 'number' && isFinite(lat) && lat>=-90 && lat<=90;}
function validLon(lon){return typeof lon === 'number' && isFinite(lon) && lon>=-180 && lon<=180;}
function isZeroZero(lat,lon){ return lat===0 && lon===0; }

function haversine(lat1, lon1, lat2, lon2){
  // Returns km
  const R = 6371;
  const dLat = toRad(lat2-lat1), dLon = toRad(lon2-lon1);
  const a = Math.sin(dLat/2)**2 + Math.cos(toRad(lat1))*Math.cos(toRad(lat2))*Math.sin(dLon/2)**2;
  return R*2*Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
}

/* ---------- Gauge factory (kept simple) ---------- */
function createGauge(svg){
  const size=120, stroke=12, r=(size-stroke)/2, startAng=Math.PI*0.75, endAng=Math.PI*0.25 + Math.PI*2;
  const ns='http://www.w3.org/2000/svg';
  const pathBg=document.createElementNS(ns,'path');
  const pathFg=document.createElementNS(ns,'path');
  const text=document.createElementNS(ns,'text');
  svg.setAttribute('viewBox',`0 0 ${size} ${size}`);
  pathBg.setAttribute('stroke','rgba(255,255,255,0.08)'); pathBg.setAttribute('fill','none'); pathBg.setAttribute('stroke-width',stroke);
  pathFg.setAttribute('fill','none'); pathFg.setAttribute('stroke-linecap','round'); pathFg.setAttribute('stroke-width',stroke-2);
  text.setAttribute('x','50%'); text.setAttribute('y','55%'); text.setAttribute('dominant-baseline','middle'); text.setAttribute('text-anchor','middle'); text.setAttribute('font-size','16'); text.textContent='0';
  svg.appendChild(pathBg); svg.appendChild(pathFg); svg.appendChild(text);
  function arcPath(a1,a2){const x1=size/2+r*Math.cos(a1),y1=size/2+r*Math.sin(a1),x2=size/2+r*Math.cos(a2),y2=size/2+r*Math.sin(a2);return `M ${x1} ${y1} A ${r} ${r} 0 ${Math.abs(a2-a1)>Math.PI?1:0} 1 ${x2} ${y2}`;}
  pathBg.setAttribute('d',arcPath(startAng,endAng));
  return {
    set(value,max=200){
      const v = (isFinite(value) ? Math.max(0,value) : 0);
      const pct = Math.max(0,Math.min(v,max))/max;
      const ang = startAng + pct*(endAng-startAng);
      pathFg.setAttribute('d',arcPath(startAng,ang));
      let col='#10b981'; if(pct>0.6) col='#f59e0b'; if(pct>0.9) col='#ef4444';
      pathFg.setAttribute('stroke',col);
      text.textContent = isFinite(value) ? (Math.round(value)) : '—';
    }
  };
}

/* ---------- Elements ---------- */
const curEl=document.getElementById('cur'), avgEl=document.getElementById('avg'), reqEl=document.getElementById('req'), distBEl=document.getElementById('distB');
const limitEl=document.getElementById('limit');
const latAEl=document.getElementById('latA'), lonAEl=document.getElementById('lonA');
const latBEl=document.getElementById('latB'), lonBEl=document.getElementById('lonB');
const startBtn=document.getElementById('startBtn'), stopBtn=document.getElementById('stopBtn');
const markStart=document.getElementById('markStart'), markEnd=document.getElementById('markEnd');
const setStartManual=document.getElementById('setStartManual'), setEndManual=document.getElementById('setEndManual');
const autoToggle=document.getElementById('autoToggle'), indicator=document.getElementById('indicator');
const exportBtn=document.getElementById('exportBtn'), statusText=document.getElementById('statusText');
const useCoordsSpeed = document.getElementById('useCoordsSpeed');

/* ---------- Gauges ---------- */
const curG=createGauge(document.getElementById('curGauge')), avgG=createGauge(document.getElementById('avgGauge')), reqG=createGauge(document.getElementById('reqGauge'));

/* ---------- State ---------- */
let watchId = null, wakelock = null;
let tripRunning=false;
let startMarker = null;    // {lat, lon, ts}
let endMarker = null;      // {lat, lon, ts}
let lastPos = null;        // {lat, lon, ts}
let traveled = 0;          // km
let startTime = null;      // ms
let speedEMA = null;
const alpha = 0.35;
let logs = [];

const MAX_ACCEPT_ACCURACY = 40;   // meters
const MIN_TIME_DIFF_MS = 400;
const MAX_SPEED_JUMP_KMH = 60;    // if implied > this, ignore
const AUTO_MARK_RADIUS_M = 30;

/* ---------- Helpers ---------- */
function setStatus(t){ statusText.textContent = t; }

async function enableWakeLock(){
  if('wakeLock' in navigator && !wakelock){
    try{
      wakelock = await navigator.wakeLock.request('screen');
      wakelock.addEventListener('release', ()=> wakelock=null);
    }catch(e){}
  }
}
function releaseWakeLock(){ if(wakelock){ wakelock.release().then(()=>wakelock=null).catch(()=>{}); } }

function resetTripState(){
  tripRunning=false; startTime=null; lastPos=null; traveled=0; speedEMA=null; logs=[];
  indicator.style.display='none';
  curEl.textContent='0'; avgEl.textContent='0'; reqEl.textContent='—'; distBEl.textContent='—';
  curG.set(0); avgG.set(0); reqG.set(0);
  setStatus('Stopped');
}

/* ---------- Distance / required calculations ---------- */

function parseCoordInputs(elLat, elLon){
  const lat = parseFloat(elLat.value);
  const lon = parseFloat(elLon.value);
  if(isNaN(lat) || isNaN(lon)) return null;
  if(!validLat(lat) || !validLon(lon)) return null;
  if(isZeroZero(lat,lon)) return null;
  return {lat, lon};
}

function remainingDistanceToB(curLat, curLon){
  // Returns km or null if dest not set or invalid
  const dest = parseCoordInputs(latBEl, lonBEl);
  if(!dest) return null;
  const straight = haversine(curLat, curLon, dest.lat, dest.lon);

  if(startMarker){
    const planned = haversine(startMarker.lat, startMarker.lon, dest.lat, dest.lon);
    // remaining planned distance is planned minus what we've travelled (but not negative)
    const rem = Math.max(0, planned - traveled);
    // Use planned remainder (more realistic). If planned is tiny or less than straight or traveled > planned, fallback to straight
    if(isFinite(rem) && rem > 0) return Math.min(rem, straight + 0.000001); // ensure not larger than straight by much
    return straight;
  }

  return straight;
}

/*
 computeRequired(limit_kmh, curLat, curLon)
 - returns required average speed in km/h, or:
    null => cannot compute (missing inputs)
    Infinity => impossible (no time left)
    number => required km/h
*/
function computeRequired(limit, curLat, curLon){
  if(typeof limit !== 'number' || !isFinite(limit) || limit <= 0) return null;
  const dest = parseCoordInputs(latBEl, lonBEl);
  if(!dest) return null;

  // Determine planned total distance
  let plannedTotal = null;
  if(startMarker){
    plannedTotal = haversine(startMarker.lat, startMarker.lon, dest.lat, dest.lon);
  } else {
    // If no start marker, estimate total as traveled + straight remaining
    const rem = remainingDistanceToB(curLat, curLon);
    if(rem === null) return null;
    plannedTotal = traveled + rem;
  }

  const allowedHours = plannedTotal / limit; // hours allowed to complete trip at speed limit
  const elapsedHours = startTime ? (Date.now() - startTime) / 3600000 : 0;
  const remainingHours = allowedHours - elapsedHours;

  const remDist = remainingDistanceToB(curLat, curLon);
  if(remDist === null) return null;

  if(remainingHours <= 0) return Infinity; // impossible
  return remDist / remainingHours;
}

/* ---------- Logging & CSV ---------- */
function pushLog(p, rawSpeed, smoothSpeed){
  logs.push({
    ts: new Date().toISOString(),
    lat: p.coords.latitude,
    lon: p.coords.longitude,
    accuracy: p.coords.accuracy,
    speed_kmh: rawSpeed,
    smooth_kmh: smoothSpeed,
    traveled_km: traveled
  });
}

function exportCSV(){
  if(logs.length===0){ alert('No logs'); return; }
  const header=['ts','lat','lon','accuracy','speed_kmh','smooth_kmh','traveled_km'];
  const rows = logs.map(r=>header.map(h=>JSON.stringify(r[h])).join(','));
  const csv=[header.join(','),...rows].join('\n');
  const blob = new Blob([csv],{type:'text/csv'});
  const url=URL.createObjectURL(blob);
  const a=document.createElement('a'); a.href=url; a.download='speedlog.csv'; a.click();
  URL.revokeObjectURL(url);
}

/* ---------- GPS Handler ---------- */
function handlePosition(p){
  // p is GeolocationPosition
  const lat = p.coords.latitude, lon = p.coords.longitude, acc = p.coords.accuracy || 999;
  const now = Date.now();

  // Accuracy filter
  if(acc > MAX_ACCEPT_ACCURACY){
    setStatus(`Ignoring low-accuracy fix (${Math.round(acc)} m)`);
    return;
  }

  // Update UI inputs with latest fix for convenience (but only if user hasn't manually filled them)
  // (Don't override when fields already filled)
  if(latAEl.value.trim() === '' && lonAEl.value.trim() === ''){
    latAEl.placeholder = lat.toFixed(6);
    lonAEl.placeholder = lon.toFixed(6);
  }
  if(latBEl.value.trim() === '' && lonBEl.value.trim() === ''){
    // leave dest placeholders blank unless user chooses to mark end
  }

  // Auto start/end
  const auto = autoToggle.checked;
  if(auto && startMarker && !tripRunning){
    const d = haversine(lat, lon, startMarker.lat, startMarker.lon) * 1000;
    if(d <= AUTO_MARK_RADIUS_M){
      startTrip();
      setStatus('Auto-started at start marker');
    }
  }
  if(auto && endMarker && tripRunning){
    const d = haversine(lat, lon, endMarker.lat, endMarker.lon) * 1000;
    if(d <= AUTO_MARK_RADIUS_M){
      stopTrip();
      setStatus('Auto-ended at end marker');
    }
  }

  if(lastPos && now - lastPos.ts < MIN_TIME_DIFF_MS) return;

  // Compute segment length
  let segKm = 0;
  if(lastPos){
    segKm = haversine(lastPos.lat, lastPos.lon, lat, lon);
    const dtH = (now - lastPos.ts) / 3600000;
    if(dtH > 0){
      const implied = segKm / dtH;
      if(implied > MAX_SPEED_JUMP_KMH){
        lastPos = {lat, lon, ts: now};
        setStatus(`Ignored speed jump (${Math.round(implied)} km/h)`);
        return;
      }
    }
  }

  // Update traveled if trip running
  if(tripRunning && lastPos){
    traveled += segKm;
  }

  // Derive raw speed
  let raw = 0;
  if(useCoordsSpeed.checked && typeof p.coords.speed === "number" && p.coords.speed !== null && !isNaN(p.coords.speed)){
    raw = Math.max(0, p.coords.speed * 3.6);
  } else if(lastPos){
    const dtSec = (now - lastPos.ts) / 1000;
    raw = dtSec > 0 ? (segKm / (dtSec / 3600)) : 0;
  }

  // Smoothing (EMA)
  if(speedEMA === null) speedEMA = raw;
  else speedEMA = alpha * raw + (1 - alpha) * speedEMA;

  pushLog(p, raw, speedEMA);

  // Update UI
  curEl.textContent = Math.round(raw);
  curG.set(raw, 200);

  const avg = computeAverage();
  avgEl.textContent = Math.round(avg);
  avgG.set(avg, 200);

  // Distance to destination (straight-line)
  const dest = parseCoordInputs(latBEl, lonBEl);
  if(dest){
    const straight = haversine(lat, lon, dest.lat, dest.lon);
    // Show whichever is most useful: if startMarker exists show remaining planned, else show straight
    let showDist = straight;
    if(startMarker){
      const planned = haversine(startMarker.lat, startMarker.lon, dest.lat, dest.lon);
      const remPlanned = Math.max(0, planned - traveled);
      // If remPlanned looks reasonable, show it, otherwise fallback to straight
      if(isFinite(remPlanned) && remPlanned > 0 && remPlanned < planned * 1.5) showDist = remPlanned;
    }
    distBEl.textContent = showDist.toFixed(2);
  } else {
    distBEl.textContent = '—';
  }

  // Required average
  const limitInput = limitEl.value.trim();
  const limit = limitInput === '' ? null : parseFloat(limitInput);
  let req = null;
  if(limit && dest){
    req = computeRequired(limit, lat, lon);
  }

  if(req === null){
    reqEl.textContent = '—';
    reqG.set(0, 200);
  } else if(req === Infinity){
    reqEl.textContent = '∞';
    reqG.set(limit, 200);
  } else {
    reqEl.textContent = Math.round(req);
    reqG.set(req, 200);
  }

  indicator.style.display = tripRunning ? 'block' : 'none';
  lastPos = {lat, lon, ts: now};

  setStatus(`Fix acc ${Math.round(acc)} m — traveled ${traveled.toFixed(3)} km`);
}

/* ---------- Trip Controls ---------- */
function computeAverage(){
  if(!startTime) return 0;
  const hours = (Date.now() - startTime) / 3600000;
  return hours > 0 ? traveled / hours : 0;
}

function startTrip(){
  if(tripRunning) return;
  if(!lastPos){ alert('Waiting for GPS fix...'); return; }
  tripRunning = true;
  startTime = Date.now();
  // If there's no start marker set explicitly, set it to current GPS position (or lastPos)
  if(!startMarker){
    startMarker = {lat: lastPos.lat, lon: lastPos.lon, ts: (new Date()).toISOString()};
  }
  indicator.style.display = 'block';
  setStatus('Trip running');
  enableWakeLock();
}

function stopTrip(){
  if(!tripRunning) return;
  tripRunning = false;
  indicator.style.display = 'none';
  setStatus('Trip stopped — export available');
  releaseWakeLock();
}

/* ---------- Marker buttons ---------- */
markStart.onclick = () => {
  if(!lastPos){ alert('Need a GPS fix to mark start from GPS'); return; }
  startMarker = {lat: lastPos.lat, lon: lastPos.lon, ts: (new Date()).toISOString()};
  // Also populate start input fields for clarity
  latAEl.value = startMarker.lat.toFixed(6);
  lonAEl.value = startMarker.lon.toFixed(6);
  setStatus('Start marker set (GPS)');
};

markEnd.onclick = () => {
  if(!lastPos){ alert('Need a GPS fix to mark end from GPS'); return; }
  endMarker = {lat: lastPos.lat, lon: lastPos.lon, ts: (new Date()).toISOString()};
  latBEl.value = endMarker.lat.toFixed(6);
  lonBEl.value = endMarker.lon.toFixed(6);
  setStatus('End marker set (GPS)');
};

setStartManual.onclick = () => {
  const lat = parseFloat(latAEl.value);
  const lon = parseFloat(lonAEl.value);
  if(isNaN(lat) || isNaN(lon)){ alert("Enter valid start latitude & longitude"); return; }
  if(!validLat(lat) || !validLon(lon)){ alert("Start coords out of range"); return; }
  if(isZeroZero(lat,lon)){ alert("Start cannot be 0,0"); return; }
  startMarker = {lat, lon, ts: (new Date()).toISOString()};
  setStatus('Start marker set (manual)');
};

setEndManual.onclick = () => {
  const lat = parseFloat(latBEl.value);
  const lon = parseFloat(lonBEl.value);
  if(isNaN(lat) || isNaN(lon)){ alert("Enter valid destination latitude & longitude"); return; }
  if(!validLat(lat) || !validLon(lon)){ alert("Destination coords out of range"); return; }
  if(isZeroZero(lat,lon)){ alert("Destination cannot be 0,0"); return; }
  endMarker = {lat, lon, ts: (new Date()).toISOString()};
  setStatus('End marker set (manual)');
};

/* ---------- Geolocation ---------- */
function initWatch(){
  if(watchId) navigator.geolocation.clearWatch(watchId);
  if(!navigator.geolocation){ alert('Geolocation not supported'); return; }
  watchId = navigator.geolocation.watchPosition(handlePosition, err=>{
    console.error(err);
    setStatus('GPS error: ' + (err.message || err.code));
  }, {enableHighAccuracy:true, maximumAge:500, timeout:10000});
}

/* ---------- UI Hooks ---------- */
startBtn.onclick = () => { if(!watchId) initWatch(); startTrip(); };
stopBtn.onclick = () => stopTrip();
exportBtn.onclick = () => exportCSV();

window.addEventListener('beforeunload', ()=>{
  if(watchId) navigator.geolocation.clearWatch(watchId);
  releaseWakeLock();
});

/* ---------- Init ---------- */
resetTripState();
initWatch();

</script>
</body>
</html>