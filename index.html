<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>HUD Speed Tracker — Improved</title>
<style>
html,body{
  margin:0;padding:0;height:100%;background:#000;color:#fff;font-family:Inter,system-ui;
  -webkit-font-smoothing:antialiased;overflow:auto;
}
.controls{position:relative;z-index:9999;padding:12px;display:flex;gap:8px;flex-wrap:wrap;}
.hud{
  position:fixed;top:0;left:0;right:0;bottom:0;
  display:flex;flex-direction:column;justify-content:center;align-items:center;
  text-align:center;pointer-events:none;
}
.gauge{width:120px;height:120px;margin:12px;}
.group{display:flex;flex-direction:column;align-items:center;margin:18px 0;}
.value{font-size:24px;font-weight:800;margin-top:-48px;}
.label{font-size:14px;color:#7f8ea3;}
input, button, select{
  z-index:9999;pointer-events:auto;font-size:14px;padding:8px;border-radius:6px;border:1px solid rgba(255,255,255,0.08);background:#0b1220;color:#fff;
}
.running-indicator{width:14px;height:14px;border-radius:50%;margin-top:8px;background:red;animation:pulse 1s infinite;display:none;}
@keyframes pulse {0%{opacity:0.3;}50%{opacity:1;}100%{opacity:0.3;}}
.small{font-size:12px;padding:6px;}
.row{display:flex;gap:8px;align-items:center;}
.status{font-size:12px;color:#7f8ea3;margin-left:6px;}
.footer{position:fixed;bottom:6px;left:6px;color:#7f8ea3;font-size:12px;pointer-events:none;}
</style>
</head>
<body>

<div class="controls">
  <input id="latB" type="number" placeholder="Dest Lat" step="any" style="width:120px;" />
  <input id="lonB" type="number" placeholder="Dest Lon" step="any" style="width:120px;" />
  <input id="limit" type="number" placeholder="Speed Limit km/h" style="width:120px;" />

  <button id="markStart" class="small">Mark Start</button>
  <button id="markEnd" class="small">Mark End</button>
  <button id="setEndManual" class="small">Set End from Input</button>
  <button id="startBtn" class="small">Start Trip</button>
  <button id="stopBtn" class="small">Stop</button>
  <button id="exportBtn" class="small">Export CSV</button>

  <label style="display:flex;align-items:center;gap:6px;"><input id="autoToggle" type="checkbox" /> Auto start/end</label>
  <label style="display:flex;align-items:center;gap:6px;"><input id="useCoordsSpeed" type="checkbox" checked /> Use GPS speed</label>
</div>

<div class="hud">
  <div class="group">
    <svg id="curGauge" class="gauge"></svg>
    <div class="value" id="cur">0</div>
    <div class="label">Current Speed</div>
  </div>
  <div class="group">
    <svg id="avgGauge" class="gauge"></svg>
    <div class="value" id="avg">0</div>
    <div class="label">Average So Far</div>
  </div>
  <div class="group">
    <svg id="reqGauge" class="gauge"></svg>
    <div class="value" id="req">0</div>
    <div class="label">Required Average</div>
  </div>
  <div class="group">
    <div class="value" id="distB">—</div>
    <div class="label">Distance to Destination (km)</div>
  </div>
  <div class="running-indicator" id="indicator"></div>
  <div class="status" id="statusText" style="margin-top:8px;pointer-events:none;"></div>
</div>

<div class="footer">Improved: route-distance + smoothing + GPS filtering</div>

<script>
/* ---------- Utilities ---------- */
function toRad(d){return d*Math.PI/180;}
function haversine(lat1, lon1, lat2, lon2){
  const R = 6371; // km
  const dLat = toRad(lat2-lat1), dLon = toRad(lon2-lon1);
  const a = Math.sin(dLat/2)**2 + Math.cos(toRad(lat1))*Math.cos(toRad(lat2))*Math.sin(dLon/2)**2;
  return R*2*Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
}

/* ---------- Compact gauge factory ---------- */
function createGauge(svg){
  const size=120, stroke=12, r=(size-stroke)/2, startAng=Math.PI*0.75, endAng=Math.PI*0.25+Math.PI*2;
  const ns='http://www.w3.org/2000/svg';
  const pathBg=document.createElementNS(ns,'path');
  const pathFg=document.createElementNS(ns,'path');
  const text=document.createElementNS(ns,'text');
  svg.setAttribute('viewBox',`0 0 ${size} ${size}`);
  pathBg.setAttribute('stroke','rgba(255,255,255,0.08)'); pathBg.setAttribute('fill','none'); pathBg.setAttribute('stroke-width',stroke);
  pathFg.setAttribute('fill','none'); pathFg.setAttribute('stroke-linecap','round'); pathFg.setAttribute('stroke-width',stroke-2);
  text.setAttribute('x','50%'); text.setAttribute('y','55%'); text.setAttribute('dominant-baseline','middle'); text.setAttribute('text-anchor','middle'); text.setAttribute('font-size','16'); text.textContent='0';
  svg.appendChild(pathBg); svg.appendChild(pathFg); svg.appendChild(text);
  function arcPath(a1,a2){const x1=size/2+r*Math.cos(a1),y1=size/2+r*Math.sin(a1),x2=size/2+r*Math.cos(a2),y2=size/2+r*Math.sin(a2);return `M ${x1} ${y1} A ${r} ${r} 0 ${a2-a1>Math.PI?1:0} 1 ${x2} ${y2}`;}
  pathBg.setAttribute('d',arcPath(startAng,endAng));
  return {
    set(value,max=200){
      const pct=Math.max(0,Math.min(value,max))/max;
      const ang=startAng + pct*(endAng-startAng);
      pathFg.setAttribute('d',arcPath(startAng,ang));
      let col='#10b981'; if(pct>0.6) col='#f59e0b'; if(pct>0.9) col='#ef4444'; pathFg.setAttribute('stroke',col);
      text.textContent=Math.round(value);
    }
  };
}

/* ---------- Elements ---------- */
const curEl=document.getElementById('cur'), avgEl=document.getElementById('avg'), reqEl=document.getElementById('req'), distBEl=document.getElementById('distB');
const limitEl=document.getElementById('limit');
const latBEl=document.getElementById('latB'), lonBEl=document.getElementById('lonB');
const startBtn=document.getElementById('startBtn'), stopBtn=document.getElementById('stopBtn');
const markStart=document.getElementById('markStart'), markEnd=document.getElementById('markEnd');
const autoToggle=document.getElementById('autoToggle'), indicator=document.getElementById('indicator');
const exportBtn=document.getElementById('exportBtn'), statusText=document.getElementById('statusText');
const useCoordsSpeed = document.getElementById('useCoordsSpeed');

/* ---------- Gauges ---------- */
const curG=createGauge(document.getElementById('curGauge')), avgG=createGauge(document.getElementById('avgGauge')), reqG=createGauge(document.getElementById('reqGauge'));

/* ---------- State ---------- */
let watchId = null;
let wakelock = null;

let tripRunning=false;
let startMarker = null;
let endMarker = null;
let lastPos = null;
let traveled = 0;
let startTime = null;
let speedEMA = null;
const alpha = 0.35;
let logs = [];

const MAX_ACCEPT_ACCURACY = 30;
const MIN_TIME_DIFF_MS = 400;
const MAX_SPEED_JUMP_KMH = 60;
const AUTO_MARK_RADIUS_M = 30;

/* ---------- Helpers ---------- */
function setStatus(t){ statusText.textContent = t; }

function enableWakeLock(){
  if('wakeLock' in navigator && !wakelock){
    navigator.wakeLock.request('screen').then(lock => {
      wakelock = lock;
      lock.addEventListener('release', ()=> wakelock = null);
    }).catch(()=>{});
  }
}

function releaseWakeLock(){
  if(wakelock){ wakelock.release().then(()=>wakelock=null).catch(()=>{}); }
}

function resetTripState(){
  tripRunning=false; startTime=null; lastPos=null; traveled=0; speedEMA=null; logs=[];
  indicator.style.display='none';
  curEl.textContent='0'; avgEl.textContent='0'; reqEl.textContent='0'; distBEl.textContent='—';
  curG.set(0); avgG.set(0); reqG.set(0);
  setStatus('Stopped');
}

function computeAverage(){
  if(!startTime) return 0;
  const h = (Date.now() - startTime)/3600000;
  return h>0 ? traveled/h : 0;
}

function remainingDistanceToB(curLat, curLon){
  const latB=parseFloat(latBEl.value), lonB=parseFloat(lonBEl.value);
  if(isNaN(latB)||isNaN(lonB)) return null;
  const straight=haversine(curLat,curLon,latB,lonB);

  let planned=null;
  if(startMarker) planned=haversine(startMarker.lat,startMarker.lon,latB,lonB);

  if(planned!==null){
    const rem=Math.max(0, planned - traveled);
    return Math.max(straight, rem);
  }
  return straight;
}

function computeRequired(limit, lat, lon){
  if(!limit) return 0;
  const latB=parseFloat(latBEl.value), lonB=parseFloat(lonBEl.value);
  if(isNaN(latB)||isNaN(lonB)) return 0;

  let planned=null;
  if(startMarker) planned=haversine(startMarker.lat,startMarker.lon,latB,lonB);

  if(planned!==null){
    const allowed = planned / limit;
    const elapsed = startTime ? (Date.now()-startTime)/3600000 : 0;
    const remainingH = allowed - elapsed;
    const remDist = remainingDistanceToB(lat,lon);
    if(remainingH <= 0) return Infinity;
    return remDist / remainingH;
  } else {
    const remDist = remainingDistanceToB(lat,lon);
    const estTotal = traveled + remDist;
    const allowed = estTotal / limit;
    const elapsed = startTime ? (Date.now()-startTime)/3600000 : 0;
    const remainingH = allowed - elapsed;
    if(remainingH <= 0) return Infinity;
    return remDist / remainingH;
  }
}

function pushLog(p, speed, smooth){
  logs.push({
    ts: new Date().toISOString(),
    lat: p.coords.latitude,
    lon: p.coords.longitude,
    accuracy: p.coords.accuracy,
    speed: speed,
    smooth: smooth,
    traveled_km: traveled
  });
}

function exportCSV(){
  if(logs.length===0){ alert('No logs'); return; }
  const header=['ts','lat','lon','accuracy','speed_kmh','smooth_kmh','traveled_km'];
  const rows = logs.map(r=>header.map(h=>JSON.stringify(r[h])).join(','));
  const csv=[header.join(','),...rows].join('\n');
  const blob = new Blob([csv],{type:'text/csv'});
  const url=URL.createObjectURL(blob);
  const a=document.createElement('a'); a.href=url; a.download='speedlog.csv'; a.click();
  URL.revokeObjectURL(url);
}

/* ---------- GPS Handler ---------- */
function handlePosition(p){
  const lat=p.coords.latitude, lon=p.coords.longitude, acc=p.coords.accuracy||999;
  const now=Date.now();

  if(acc>MAX_ACCEPT_ACCURACY){
    setStatus(`Ignoring low-accuracy fix (${Math.round(acc)} m)`);
    return;
  }

  const auto=autoToggle.checked;
  if(auto && startMarker && !tripRunning){
    const d=haversine(lat,lon,startMarker.lat,startMarker.lon)*1000;
    if(d<=AUTO_MARK_RADIUS_M){
      startTrip();
      setStatus('Auto-started at start marker');
    }
  }
  if(auto && endMarker && tripRunning){
    const d=haversine(lat,lon,endMarker.lat,endMarker.lon)*1000;
    if(d<=AUTO_MARK_RADIUS_M){
      stopTrip();
      setStatus('Auto-ended at end marker');
    }
  }

  if(lastPos && now-lastPos.ts<MIN_TIME_DIFF_MS) return;

  let segKm=0;
  if(lastPos){
    segKm=haversine(lastPos.lat,lastPos.lon,lat,lon);
    const dtH=(now-lastPos.ts)/3600000;
    if(dtH>0){
      const implied=segKm/dtH;
      if(implied>MAX_SPEED_JUMP_KMH){
        lastPos={lat,lon,ts:now};
        setStatus(`Ignored jump (${Math.round(implied)} km/h)`);
        return;
      }
    }
  }

  if(tripRunning && lastPos) traveled+=segKm;

  let raw=0;
  if(useCoordsSpeed.checked && typeof p.coords.speed==="number" && p.coords.speed!==null){
    raw=Math.max(0,p.coords.speed*3.6);
  } else if(lastPos) {
    const dtSec=(now-lastPos.ts)/1000;
    raw=dtSec>0 ? (segKm/(dtSec/3600)) : 0;
  }

  if(speedEMA===null) speedEMA=raw;
  else speedEMA = 0.35*raw + 0.65*speedEMA;

  pushLog(p,raw,speedEMA);

  curEl.textContent=Math.round(raw);
  curG.set(raw,200);

  const avg=computeAverage();
  avgEl.textContent=Math.round(avg);
  avgG.set(avg,200);

  const latB=parseFloat(latBEl.value), lonB=parseFloat(lonBEl.value);
  if(!isNaN(latB)&&!isNaN(lonB)){
    distBEl.textContent=haversine(lat,lon,latB,lonB).toFixed(2);
  } else distBEl.textContent='—';

  const limit=parseFloat(limitEl.value)||0;
  if(limit>0 && !isNaN(latB)&&!isNaN(lonB)){
    let req=computeRequired(limit,lat,lon);
    if(!isFinite(req)) req=Infinity;
    reqEl.textContent = req===Infinity ? '—' : Math.round(req);
    reqG.set(isFinite(req) ? req : limit,200);
  } else {
    reqEl.textContent='0'; reqG.set(0,200);
  }

  indicator.style.display=tripRunning?'block':'none';

  lastPos={lat,lon,ts:now};

  setStatus(`Accuracy ${Math.round(acc)} m — traveled ${traveled.toFixed(3)} km`);
}

/* ---------- Trip Controls ---------- */
function startTrip(){
  if(tripRunning) return;
  if(!lastPos){ alert('Waiting for GPS fix...'); return; }
  tripRunning=true;
  startTime=Date.now();
  if(!startMarker){
    startMarker={lat:lastPos.lat, lon:lastPos.lon, ts:new Date().toISOString()};
  }
  indicator.style.display='block';
  setStatus('Trip running');
  enableWakeLock();
}

function stopTrip(){
  if(!tripRunning) return;
  tripRunning=false;
  indicator.style.display='none';
  setStatus('Trip stopped — export available');
  releaseWakeLock();
}

markStart.onclick=()=>{
  if(!lastPos){ alert('Need a GPS fix'); return; }
  startMarker={lat:lastPos.lat,lon:lastPos.lon,ts:new Date().toISOString()};
  setStatus('Start marker set');
};

markEnd.onclick=()=>{
  if(!lastPos){ alert('Need a GPS fix'); return; }
  endMarker={lat:lastPos.lat,lon:lastPos.lon,ts:new Date().toISOString()};
  latBEl.value=endMarker.lat.toFixed(6);
  lonBEl.value=endMarker.lon.toFixed(6);
  setStatus('End marker set');
};

/* ---------- NEW: Manual End Marker ---------- */
document.getElementById('setEndManual').onclick = () => {
  const lat=parseFloat(latBEl.value);
  const lon=parseFloat(lonBEl.value);

  if(isNaN(lat) || isNaN(lon)){
    alert("Enter destination lat & lon first.");
    return;
  }

  endMarker = {
    lat,
    lon,
    ts: new Date().toISOString()
  };

  setStatus("End marker set manually from input fields");
};

/* ---------- Geolocation ---------- */
function initWatch(){
  if(watchId) navigator.geolocation.clearWatch(watchId);
  if(!navigator.geolocation){ alert('Geolocation not supported'); return; }
  watchId=navigator.geolocation.watchPosition(handlePosition, err=>{
    console.error(err);
    setStatus('GPS error: '+(err.message||err.code));
  }, {enableHighAccuracy:true, maximumAge:500, timeout:5000});
}

startBtn.onclick=()=>{ if(!watchId) initWatch(); startTrip(); };
stopBtn.onclick=()=>stopTrip();
exportBtn.onclick=()=>exportCSV();

window.addEventListener('beforeunload',()=>{
  if(watchId) navigator.geolocation.clearWatch(watchId);
  releaseWakeLock();
});

resetTripState();
initWatch();

</script>
</body>
</html>

